package main

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

type PreUrl struct {
	Url    string `json:"datos"` //Definimos que el campo Url será de tipo igual que el item "datos" de JSON obtenido
	Client *http.Client
}

type AutoGenerated []struct {
	Origen     Origen     `json:"origen"`
	Elaborado  string     `json:"elaborado"`
	Nombre     string     `json:"nombre"`
	Provincia  string     `json:"provincia"`
	Prediccion Prediccion `json:"prediccion"`
	ID         int        `json:"id"`
	Version    float64    `json:"version"`
}

type Origen struct {
	Productor string `json:"productor"`
	Web       string `json:"web"`
	Enlace    string `json:"enlace"`
	Language  string `json:"language"`
	Copyright string `json:"copyright"`
	NotaLegal string `json:"notaLegal"`
}

type ProbPrecipitacion struct {
	Value   int    `json:"value"`
	Periodo string `json:"periodo"`
}

type CotaNieveProv struct {
	Value   string `json:"value"`
	Periodo string `json:"periodo"`
}

type EstadoCielo struct {
	Value       string `json:"value"`
	Periodo     string `json:"periodo"`
	Descripcion string `json:"descripcion"`
}

type Viento struct {
	Direccion string `json:"direccion"`
	Velocidad int    `json:"velocidad"`
	Periodo   string `json:"periodo"`
}

type RachaMax struct {
	Value   string `json:"value"`
	Periodo string `json:"periodo"`
}

type Dato struct {
	Value int `json:"value"`
	Hora  int `json:"hora"`
}

type Temperatura struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}

type SensTermica struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}

type HumedadRelativa struct {
	Maxima int    `json:"maxima"`
	Minima int    `json:"minima"`
	Dato   []Dato `json:"dato"`
}

type Dia struct {
	ProbPrecipitacion []ProbPrecipitacion `json:"probPrecipitacion"`
	CotaNieveProv     []CotaNieveProv     `json:"cotaNieveProv"`
	EstadoCielo       []EstadoCielo       `json:"estadoCielo"`
	Viento            []Viento            `json:"viento"`
	RachaMax          []RachaMax          `json:"rachaMax"`
	Temperatura       Temperatura         `json:"temperatura"`
	SensTermica       SensTermica         `json:"sensTermica"`
	HumedadRelativa   HumedadRelativa     `json:"humedadRelativa"`
	UvMax             int                 `json:"uvMax,omitempty"`
	Fecha             string              `json:"fecha"`
}

type Prediccion struct {
	Dia []Dia `json:"dia"`
}

type Diaria struct { //Obtenemos los diferentes datos correspondientes a la respuesta JSON y las asignamos a cada uno de los campos
	ProbPrecipitacio int       `json:"probPrecipitacion"`
	TemperaturaMax   int       `json:"maxima"`
	TemperaturaMin   int       `json:"minima"`
	HumitatRelativa  int       `json:"humedadRelativa"`
	Time             time.Time `json:"-"` //No tiene vinculación con el JSON (por eso añadimos "-")
}

// Realizaremos una funciómn para gestionar la obtención de los datos climatológicos y lo primero que tenemos que hacer es hacer referencia al package nativo http a través del struct Prediccio
func (parte *Diaria) GetPrediccions() (*Diaria, error) {
	dire, _ := obtenirPreUrl()
	valors, err := GetPrediccio(dire)
	return valors, err
}

func obtenirPreUrl() (string, error) {
	//Definimos la variable url con el endpoint correspondiente a la predicción específica de un municipio
	url := "https://opendata.aemet.es/opendata/api/prediccion/especifica/municipio/diaria/08001/?api_key=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJnZWIuYmVnLjczQGdtYWlsLmNvbSIsImp0aSI6ImY1ODM3MWZjLTA4Y2ItNDg0Mi05Y2UwLTU4M2UxYmFjM2ZmNyIsImlzcyI6IkFFTUVUIiwiaWF0IjoxNzIzMTI5MzE4LCJ1c2VySWQiOiJmNTgzNzFmYy0wOGNiLTQ4NDItOWNlMC01ODNlMWJhYzNmZjciLCJyb2xlIjoiIn0.g4_ntwvsFPddAiHEcb-NQyc9yCDAUJ0pP5khMTR1w7E"

	//Preparamos la petición utilizando el package http
	request, _ := http.NewRequest("GET", url, nil)
	//Añadimos la cabecera de la petición que no cachee la petición
	request.Header.Add("cache-control", "no-cache")

	//Realizamos la petición a la API utilizando el método Do del cliente http, y transmitimos la variable req como parámetro, que contiene la petición en sí
	res, err := http.DefaultClient.Do(request)

	//Si hay un error en la conexión con la API, mostramos un mensaje de error
	if err != nil {
		log.Println("Error!!! Conectando a la API de AEMET")
		return "", err //Retornamos un error controlado
	}

	defer res.Body.Close()                //Diferimos la respuesta
	body, err := ioutil.ReadAll(res.Body) //Leemos el cuerpo de la respuesta de la petición

	//Si hay un error en la lectura del JSON, mostramos un mensaje de error
	if err != nil {
		log.Println("Error!!! hay un error leyendo el Json")
		return "", err //Retornamos un error controlado

	}
	preUrl := PreUrl{}                  //Creamos un struct vacío de tipo PreUrl
	err = json.Unmarshal(body, &preUrl) //Almacenamos el valor del body en el struct PreUrl
	if err != nil {
		log.Println("Error!!! Unmarshall - hay un error convirtiendo el Json", err)
		return "", err
	}
	return preUrl.Url, err //Retornamos la URL y el error controlado
}

func GetPrediccio(url string) (*Diaria, error) {
	//Recibimos la variable url con el endpoint correspondiente a la predicción específica de un municipio
	//Preparamos la petición utilizando el package http
	request, _ := http.NewRequest("GET", url, nil)
	request.Header.Add("cache-control", "no-cache")

	//Ejecutar la petición a la API
	res, err := http.DefaultClient.Do(request)

	if err != nil {
		log.Println("Error!!! Conectando a la API de AEMET")
		return nil, err //Retornamos un error controlado
	}

	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Println("Error!!! hay un error leyendo el Json")
		return nil, err //Retornamos un error controlado

	}
	prediccio := AutoGenerated{}                    //Creamos un struct vacío de tipo AutoGenerated
	var precipitacio, tempMax, tempMin, humitat int //Inicializamos variables para guardar los valores climatológicos principales que utilizaremos
	err = json.Unmarshal([]byte(body), &prediccio)  //Almacenamos el valor del body en el struct AutoGenerated
	if err != nil {
		log.Println("Error!!! Unmarshall - hay un error convirtiendo el Json", err)
		return nil, err
	}

	//Desestructuramos el JSON para obtener los valores de precipitación, temperatura máxima, temperatura mínima y humedad
	precipitacio = prediccio[0].Prediccion.Dia[0].ProbPrecipitacion[0].Value
	tempMax = prediccio[0].Prediccion.Dia[0].Temperatura.Maxima
	tempMin = prediccio[0].Prediccion.Dia[0].Temperatura.Minima
	humitat = prediccio[0].Prediccion.Dia[0].HumedadRelativa.Maxima

	var parte = Diaria{
		ProbPrecipitacio: precipitacio,
		TemperaturaMax:   tempMax,
		TemperaturaMin:   tempMin,
		HumitatRelativa:  humitat,
		Time:             time.Now(),
	}

	return &parte, err //Retornamos los valores climatológicos y el error controlado

}
